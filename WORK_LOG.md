Name: Hannah

| Date    |      Time       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Update |
|:--------|:---------------:|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sept 24 | 11:15am-11:55am |                                                                                                                                                                                                                                           During this block, I tried to think of different ways that I could solve the problem. The main thing that I thought about was that a set doesn't allow duplicates, so in some way I think that using a set will help to optimize the run time because you don't have to ever remove duplicates at the end. The second thing that I am still playing with is that if you take the text and simply remove words as you go that DO exist in the dictionary, the resulting words are the ones that don't exist and they are in order. However, there are duplicates, and in general I don't think that this is going to be the most efficient way of solving it. |
| Sept 25 |   3pm-3:45pm    |                                                                                                                                                                                                                                                                                                                                                              I am trying to implement the idea that I came up with last class where I simply remove every word that does exist in the dictionary. I think that this will work best if I duplicate the array of strings over to an arraylist, and my idea is to a nested for loop that will index through every word of the dicitonary and see if it matches with the given word in text. However, as I even just write this out, I can tell that it is probably going to take wayyyyy too long, but I am going to try to implement it just as a start. |
| Sept 25 |  3:45pm-4:15pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Ok so I tried that and it literally took forever every single test timed out. So, what I think I'm gonna do next is implement the code from SpellingBee from last year, and see how correct that works. My goal for V1 is to get something that works whether or not it passes the time checks. Again, I doubt SpellingBee will pass the time checks, but I'm thinking that it will almost definitely be faster than what I have now! |
| Sept 25 |  4:15pm-5:15pm  |                                                                                                                                                                                                                         Ok so I implemented binary search and it worked! I am excited to walk you through this. Basically, I inputted just a normal binary search algorithm into the code and then I started prompting chatGPT and asking it about different data structures. For example, I asked "what is the optimal data structure with constant lookup time that keeps the order of the elements" and after enough prompting, it seemed that a LinkedHashSet would be best. So after that, I started doing a bunch of research on the documentation of it and figured out how the hashmap works and implemented it. After a bunch of trial and error with the syntax and stuff, I got it to work! |
| Oct 2   |   3pm-4:45pm    |                                                                                                                                                                                                                                                                                                                                                                  I thought through roughly what functions I would want in each class, starting with the trie class and the node class. For the trie class, I am starting with an insert method and a find method, and when I eventually create the TST class, I am going to make the function headers math so it is easy to interchange which one I am using. For the node class, I will have a method that finds whether or not its a word, setting whether it's a word, and a getnext method that returns that array that comes off of a given node. |
| Oct 5   |   8:30pm-9pm    |                                                                                                                                                   Finished thinking about the implementation of the trie class and implemented it. Both the insert and the find methods actually very similar, they just return different things and you add nodes for insert. The insert method loops through each character in the string and uses its ASCII value for an index to traverse/build nodes in the trie. If the node at the "child" index doesn't exist, it creates a new node in that spot to ensure that the path for the word is fully there. The find method starts with an identical loop, but when the "child" node is null, this time it returns false instead of adding a node. Also, if the path did exist but the word is not a valid word, it also returns false. Otherwise, it returns true. |
| Oct 6   |  11am-11:30am   | Today, we had worktime in class. Since I finished the trie class, I started thinking about how to implement the TST class. The first thing that happened was I realized that you have to have two separate node classes, one for trie and one for TST. This is because for a TrieNode, you need the getNext function to give you the array of all the possible following letters. However, for a TSTnode, you want the getNext function to return an array of length 3 with each representing a path based on whether your letter is greater than, less than, or equal to the letter in the TST. So, I implemented these two node classes. Also, for the TSTNode, I talked through it with Mr. Blick, and we figured out that you need a setLetter function because while a TrieNode knows its own letter, a TSTNode inherently does not. Therefore, you should store the node's letter in a variable. |
| Oct 6   | 11:30am-11:55am |                                                                                                                                                                                                                                                                                                                                                                                                                   Honestly, I just spent this whole time thinking about how TSTs work. I am quite confused by them, so I think I need to do some more thinking before I jump in and keep coding. I might also do some research. I did code in that the root should always be the letter M so that the TST is as efficient as possible because its content will be split to both sides instead of one side heavy. Tonight I am going to hopefully start implementing the insert function and finish it! |
| Oct 6   |   6:20pm-7pm    |                                                                                                                                                                                                                                                                                                                                                                                                                                                 I realized that I wasn't finished with the TSTNode class, so I thought about everything that I am going to need to be able to access regarding the node. I need a bunch of getters and setters so that I can see/change info as it is being traced through. I also need to have something that returns the array of the children nodes (left, center, right). Lastly I need to be able to check if it is a terminal letter or not (if it ends a word). |
| Oct 8   |   9am-9:30am    |                                                                                                                                                                     So I am currently trying to figure out the TST method of insert. I am thinking about how you navigate through the different nodes, and especially, what is the best way to set a null child node to a letter. Mr. Blick showed me that it would be more efficient to rewrite my TSTNode class so that it takes in a parameter of a letter, allowing me to be more efficient with setting a null node to a value. Additionally, I am still struggling with the idea that a node isn't an actual node per say, but it is just a part of the path. This is confusing because you don't accept a letter until you have moved past the node. This feels counterintuitive so I am trying to understand it more before implementing find. |
| Oct 8   |  9:30am-9:55am  |                                                                                                                                                                                                                                                                                                                                                                                     I finished my TST insert method and actually realized there were a lot of places where I could optimize. By setting the root to always be m, I never needed to check if the root was blank, so that got rid of an entire if statement. I now need to start working on the find method. I am assuming that the find and insert will be very similar to each other, especially because the trie insert and find were really similar. The main difference is that instead of adding a node, you need to return false. |
| Oct 8   |   6pm-6:45pm    |                                                                                                                                                                                                                                                                                                                                                                                                                                              I finally finished! Most of the TST find method was the same, as I predicted. I honestly spent a lot of this time debugging, because when I first created it I had an infinite loop and turns out I was setting every node to center instead of left, right, etc. After fixing that, everything worked pretty well. I added in some optimizations and went through and found different if statements that didn't actually need to be there which was fun! |


To add a new row to the table, click into a cell and then hit shift-enter.
