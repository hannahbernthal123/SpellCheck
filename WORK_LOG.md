Name: Hannah

| Date    |      Time       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Update |
|:--------|:---------------:|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sept 24 | 11:15am-11:55am |                                                                                         During this block, I tried to think of different ways that I could solve the problem. The main thing that I thought about was that a set doesn't allow duplicates, so in some way I think that using a set will help to optimize the run time because you don't have to ever remove duplicates at the end. The second thing that I am still playing with is that if you take the text and simply remove words as you go that DO exist in the dictionary, the resulting words are the ones that don't exist and they are in order. However, there are duplicates, and in general I don't think that this is going to be the most efficient way of solving it. |
| Sept 25 |   3pm-3:45pm    |                                                                                                                                                                                                            I am trying to implement the idea that I came up with last class where I simply remove every word that does exist in the dictionary. I think that this will work best if I duplicate the array of strings over to an arraylist, and my idea is to a nested for loop that will index through every word of the dicitonary and see if it matches with the given word in text. However, as I even just write this out, I can tell that it is probably going to take wayyyyy too long, but I am going to try to implement it just as a start. |
| Sept 25 |  3:45pm-4:15pm  |                                                                                                                                                                                                                                                                                                                Ok so I tried that and it literally took forever every single test timed out. So, what I think I'm gonna do next is implement the code from SpellingBee from last year, and see how correct that works. My goal for V1 is to get something that works whether or not it passes the time checks. Again, I doubt SpellingBee will pass the time checks, but I'm thinking that it will almost definitely be faster than what I have now! |
| Sept 25 |  4:15pm-5:15pm  |                                                                       Ok so I implemented binary search and it worked! I am excited to walk you through this. Basically, I inputted just a normal binary search algorithm into the code and then I started prompting chatGPT and asking it about different data structures. For example, I asked "what is the optimal data structure with constant lookup time that keeps the order of the elements" and after enough prompting, it seemed that a LinkedHashSet would be best. So after that, I started doing a bunch of research on the documentation of it and figured out how the hashmap works and implemented it. After a bunch of trial and error with the syntax and stuff, I got it to work! |
| Oct 2   |   3pm-4:45pm    |                                                                                                                                                                                                                I thought through roughly what functions I would want in each class, starting with the trie class and the node class. For the trie class, I am starting with an insert method and a find method, and when I eventually create the TST class, I am going to make the function headers math so it is easy to interchange which one I am using. For the node class, I will have a method that finds whether or not its a word, setting whether it's a word, and a getnext method that returns that array that comes off of a given node. |
| Oct 5   |   8:30pm-9pm    | Finished thinking about the implementation of the trie class and implemented it. Both the insert and the find methods actually very similar, they just return different things and you add nodes for insert. The insert method loops through each character in the string and uses its ASCII value for an index to traverse/build nodes in the trie. If the node at the "child" index doesn't exist, it creates a new node in that spot to ensure that the path for the word is fully there. The find method starts with an identical loop, but when the "child" node is null, this time it returns false instead of adding a node. Also, if the path did exist but the word is not a valid word, it also returns false. Otherwise, it returns true. |


To add a new row to the table, click into a cell and then hit shift-enter.
